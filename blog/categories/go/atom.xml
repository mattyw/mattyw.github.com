<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: go | mattyw]]></title>
  <link href="http://mattyw.github.io/blog/categories/go/atom.xml" rel="self"/>
  <link href="http://mattyw.github.io/"/>
  <updated>2013-06-28T08:32:43+01:00</updated>
  <id>http://mattyw.github.io/</id>
  <author>
    <name><![CDATA[Matt Williams]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Taming the cloud with juju and raspberry pi]]></title>
    <link href="http://mattyw.github.io/blog/2013/06/27/taming-the-cloud-with-juju-and-raspberry-pi/"/>
    <updated>2013-06-27T08:01:00+01:00</updated>
    <id>http://mattyw.github.io/blog/2013/06/27/taming-the-cloud-with-juju-and-raspberry-pi</id>
    <content type="html"><![CDATA[<h2>The idea</h2>

<p>We&rsquo;re going to use a raspberry pi and juju to setup a wordpress blog on aws.</p>

<p>The raspberry pi is an amazing little gadget. Low power enough that I don&rsquo;t feel guilty about leaving it turned on overnight, but flexible enough that I can shove leds into it to grab my attention if needed.</p>

<p><a href="http://juju.ubuntu.com">Juju</a> is ubuntu&rsquo;s answer to setting up services in the cloud. Once installed you simply setup your credentials with an existing cloud provider like aws or hp cloud and then deploy things into it. Setting up wordpress for example is as simple as
<code>bash
juju bootstrap # Setup the cloud environment
juju deploy wordpress # Start an instance and install wordpress on it
juju deploy mysql # Start an instance and install mysql on it
juju add-relation wordpress mysql # Connect wordpress and mysql together
juju expose wordpress #Allow wordpress to be accessed from a public ip
</code></p>

<h2>The Plan</h2>

<ol>
<li>Install go onto the raspberry pi</li>
<li>Install juju</li>
<li>Deploy a wordpress blog</li>
</ol>


<p>We&rsquo;re going to be installing the latest version of juju which is written in go.</p>

<h2>Installing Go</h2>

<p>Dave Cheney has written an excellent article on <a href="http://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi">Installing go on the raspberry pi</a>. On my model B (1.0 revision) I had to update raspi-config so that I could select the 240M/16M memory split, but you might have to see how you get on here. I choose to skip the tests and just ran ./make.bash to build go rather than all.bash.</p>

<p>I was unable to build juju using go 1.0.3. I ended up building go 1.1.1 from source, which seemed to work fine. From memory I believe you need to setup a folder to be your GOPATH before you can install the latest version of go.</p>

<h2>Installing Juju</h2>

<p>Getting the latest tip of juju-core is easy using the go get command, it grabs all the dependencies for you, it does mean we&rsquo;re grabbing tip, but there are ways to fix that later if we need to. juju-core is hosted on launchpad.net which uses bazaar for source control. This means you need to install it before you can run go get. I was able to install it on raspian using
<code>bash
sudo apt-get update
sudo apt-get bzr
</code>
Without doing the update I was unable to grab all of bzr&rsquo;s dependencies, so I recommend running the update first.</p>

<p>Once bzr is installed you can install juju using go get:
<code>bash
sudo apt-get install libcurl4-gnutls-dev
go get launchpad.net/juju-core/...
</code>
When it&rsquo;s finished you should find a juju binary installed. Mine ended up in my GOPATH, I think because I had something setup wrong somewhere. But if you&rsquo;ve got this far I&rsquo;m sure you&rsquo;ll be able to find it.</p>

<h2>Setting up Juju</h2>

<p>There&rsquo;s much better instructions for setting up juju <a href="https://juju.ubuntu.com/get-started/">here</a> The basic steps come down to</p>

<ol>
<li>Setting up a public key</li>
<li>Generating an environments.yaml file</li>
<li>Filling the file in with the data for your cloud provider</li>
</ol>


<p>I configured juju for aws. My ~/.juju/environments.yaml file looked like this:
```yaml
default: amazon
environments:
  amazon:</p>

<pre><code>type: ec2
  access-key: MY AWS ACCESS KEY
  secret-key: MY AWS SECRET KEY
  control-bucket: mattyw-ec2-bucket
  admin-secret: mattyw-ec2-admin
</code></pre>

<p>```
Once you&rsquo;ve done this, try running <strong>juju bootstrap</strong>. If it finishes without error wait a minute or so and run <strong>juju status</strong>, If all goes well you should see something like this</p>

<p>```yaml
$ juju status
machines:
  &ldquo;0&rdquo;:</p>

<pre><code>agent-state: started
agent-version: 1.11.0
dns-name: ec2-23-20-228-111.compute-1.amazonaws.com
instance-id: i-0bfc3d64
series: precise
</code></pre>

<p>services: {}
```</p>

<p>Now we can start the business of getting a blog up and running:</p>

<p><code>bash
juju deploy wordpress
juju deploy mysql
juju add-relation wordpress mysql
juju expose wordpress
</code>
You might have to wait a few minutes for everything to start up, keep taking a look at the output of <strong>juju status</strong> until you see all the agent-states running and expose true on wordpress.</p>

<p>When it&rsquo;s done you should see something like this in your juju status output:
```yaml
 wordpress:</p>

<pre><code>charm: cs:precise/wordpress-15
exposed: true
relations:
  db:
  - mysql
  loadbalancer:
  - wordpress
units:
  wordpress/0:
    agent-state: started
    agent-version: 1.11.0
    machine: "1"
    public-address: ec2-54-234-76-38.compute-1.amazonaws.com
</code></pre>

<p>```</p>

<p>Now point your web browser to the url in public-address and there you go, you&rsquo;re deploying stuff from your pi.</p>

<p>Juju doesn&rsquo;t stop at just deploying blogs. Check out <a href="http://juju.ubuntu.com">Juju</a> to see what else it can do for you</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[why I like elixir (and other go programmers might too)]]></title>
    <link href="http://mattyw.github.io/blog/2013/06/17/why-i-like-elixir/"/>
    <updated>2013-06-17T21:10:00+01:00</updated>
    <id>http://mattyw.github.io/blog/2013/06/17/why-i-like-elixir</id>
    <content type="html"><![CDATA[<h2>My journey to elixir</h2>

<p>Erlang was the first functional language I ever used. When I first started reading <a href="http://pragprog.com/book/jaerlang/programming-erlang">Programming Erlang</a> by Joe Armstrong I was hooked, I was fascinated in a language where &ldquo;=&rdquo; didn&rsquo;t indicate an assignment, and the idea of pattern matching immediately struck a chord with me, I loved the one module per &lsquo;process&rsquo; thing. Erlang was set to become my favourite language, there was only one problem.</p>

<p>I didn&rsquo;t like the syntax</p>

<p>It&rsquo;s a completely personal view, I know people who love the syntax, I just didn&rsquo;t. To me it just didn&rsquo;t have what Christopher Alexander in &ldquo;The Timeless way of building&rdquo; calls &ldquo;quality without a name&rdquo;. I suppose I just didn&rsquo;t find it fun to type. So after re writing a couple of internal libraries in erlang to see what they looked like (they were much shorter and quite easy to read) I stopped using it, and started playing around with other languages like haskell and clojure.</p>

<p>Clojure was my first lisp dialect and I enjoy it alot, the syntax, the whole homoiconicity thing, macro&rsquo;s aren&rsquo;t something you should use all the time &ndash; but it&rsquo;s comforting to know they&rsquo;re there to fall back on if you need them.</p>

<p>Parallel to this functional language experimentation was another path &ndash; languages I used at work, which has seen me recently move from writing mostly in Python to Go. Go&rsquo;s channels and go routines are great, but when I started writing go code seriously (about 8 months ago) there was something that immediately stuck me.</p>

<p>```go
thing, err := someFunction()
if err != nil {</p>

<pre><code>//handle the error
</code></pre>

<p>}
```
Now, I&rsquo;m not going to start complaining about go&rsquo;s error handling, because I like it. But sometimes I would like to be able to make use of pattern matching and do something like this:</p>

<p><code>go
{thing, nil} = someFunction()
</code></p>

<p>And have my goroutine just dies if it fails. I know that&rsquo;s not go&rsquo;s philosophy with errors, and that&rsquo;s fine. I&rsquo;m just saying.</p>

<h2>Work and Fun Collide</h2>

<p>I&rsquo;ve spent the past 6 months saying to people that I would like a lisp dialect to be built onto go. What I really meant was I wanted a language that would let me do go style concurrency and play around with a repl, macros and all that functional programming <em>fun</em> stuff.</p>

<p>It looks to me that elixir provides exactly that.</p>

<p>Just look at these two programs. Both call a 10 second sleeping function on a seperate &lsquo;thread&rsquo; and wait for the response. The first in go, the second in elixir.
```go
package main</p>

<p>import (</p>

<pre><code>"fmt"
"time"
</code></pre>

<p>)</p>

<p>func longRun(response chan string) {</p>

<pre><code>time.Sleep(10e9)
response &lt;- "done"
</code></pre>

<p>}</p>

<p>func main() {</p>

<pre><code>response := make(chan string)
go longRun(response)
value := &lt;-response
fmt.Println(value)
</code></pre>

<p>}
<code>
</code>elixir
defmodule Main do</p>

<p>  def longRun(pid) do</p>

<pre><code>:timer.sleep(10000)
pid &lt;- {:result, :done}
</code></pre>

<p>  end</p>

<p>  def main() do</p>

<pre><code>spawn(__MODULE__, :longRun, [self])
receive do
  {:result, value} -&gt;
    IO.puts value
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>Main.main()
```</p>

<p>They&rsquo;re not too different, elixir has spawn where go has &lsquo;go&rsquo; and elxir has receive where go has select. There&rsquo;s no denying that they&rsquo;re completely different languages, in some rather crude tests I&rsquo;ve done go does seem to be largely faster, but elixir let&rsquo;s me do meta-programming whilst forgetting about types.</p>

<p>I expect to be blogging alot more about elixir in the future</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unique contraint in mongo]]></title>
    <link href="http://mattyw.github.io/blog/2013/06/12/unique-contraint-in-mongo/"/>
    <updated>2013-06-12T12:11:00+01:00</updated>
    <id>http://mattyw.github.io/blog/2013/06/12/unique-contraint-in-mongo</id>
    <content type="html"><![CDATA[<p>My first post on my new blog, so let&rsquo;s keep it simple.</p>

<p>In sql databases you can specify unique constrains on certain columns, like this example from postgres:</p>

<p>``` sql
create unique index idx_UniqRef on FooBar (</p>

<pre><code>   UniqRef ASC);
</code></pre>

<p>```
The question is: <strong>Is it possible to do this in a schema-less database like mongo?</strong>
Lets' start writing some code that we want to fail. For this I&rsquo;m going to use go and <a href="http://labix.org/mgo">Gustavo&rsquo;s mgo library</a></p>

<p><code>go
+package main
+
+import (
+  "labix.org/v2/mgo"
+  "log"
+)
+
+type FooBar struct {
+  Name   string
+  Age    int
+  UniqId int
+}
+
+func main() {
+  session, err := mgo.Dial("127.0.0.1")
+  if err != nil {
+    log.Fatal(err)
+  }
+
+  coll := session.DB("test").C("uniq_test")
+  coll.DropCollection()
+
+  a := FooBar{"Foo", 1, 1}
+  b := FooBar{"Bar", 2, 1}
+
+  err = coll.Insert(a)
+  if err != nil {
+    log.Fatal(err)
+  }
+  err = coll.Insert(b)
+  if err == nil {
+    log.Fatal("We wrote something but wanted to fail!")
+  }
+
+}
</code>
Nothing too fancy here:</p>

<ul>
<li>Create a connection to our collection

<ul>
<li>If the collection exists drop it (useful for iterating quickly on this test)</li>
</ul>
</li>
<li>Create two structures with a UniqId field duplicated</li>
<li>Insert both, if the second insert doesn&rsquo;t fail log an error</li>
</ul>


<p>If we run it as is, we see our failure
<code>bash
2013/06/12 13:14:51 We wrote something but wanted to fail!
exit status 1
</code></p>

<p>Now we&rsquo;re in a position to start looking into a solution, and it turns out we don&rsquo;t
have to look far. Just like postgres mongo has indexes, we can create one using ensureIndex.
Here&rsquo;s how it looks in the mgo library:</p>

<p>``` go</p>

<pre><code>//Let's try an index
index := mgo.Index{
    Key: []string{"uniqid"},
    Unique: true,
}
err = coll.EnsureIndex(index)
if err != nil {
    log.Fatal(err)
}
</code></pre>

<p>```</p>

<p>This creates an index on our uniqid field and forces it to be unique. If we call this code
before we try inserting here&rsquo;s what we get</p>

<p><code>bash
Failed to write! E11000 duplicate key error index: test.uniq_test.$uniqid_1  dup key: { : 1 }
</code></p>

<p>There we go, it also supports compound indexes which lets you specify multiple fields which must
be unique, but I&rsquo;m not going to cover that here. The <a href="http://docs.mongodb.org/manual/core/indexes/">mongo documention</a>
is a great source for more information</p>
]]></content>
  </entry>
  
</feed>
