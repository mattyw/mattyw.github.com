<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: go | mattyw]]></title>
  <link href="http://mattyw.github.io/blog/categories/go/atom.xml" rel="self"/>
  <link href="http://mattyw.github.io/"/>
  <updated>2013-06-27T17:53:44+01:00</updated>
  <id>http://mattyw.github.io/</id>
  <author>
    <name><![CDATA[Matt Williams]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[why I like elixir (and other go programmers might too)]]></title>
    <link href="http://mattyw.github.io/blog/2013/06/17/why-i-like-elixir/"/>
    <updated>2013-06-17T21:10:00+01:00</updated>
    <id>http://mattyw.github.io/blog/2013/06/17/why-i-like-elixir</id>
    <content type="html"><![CDATA[<h2>My journey to elixir</h2>

<p>Erlang was the first functional language I ever used. When I first started reading <a href="http://pragprog.com/book/jaerlang/programming-erlang">Programming Erlang</a> by Joe Armstrong I was hooked, I was fascinated in a language where &ldquo;=&rdquo; didn&rsquo;t indicate an assignment, and the idea of pattern matching immediately struck a chord with me, I loved the one module per &lsquo;process&rsquo; thing. Erlang was set to become my favourite language, there was only one problem.</p>

<p>I didn&rsquo;t like the syntax</p>

<p>It&rsquo;s a completely personal view, I know people who love the syntax, I just didn&rsquo;t. To me it just didn&rsquo;t have what Christopher Alexander in &ldquo;The Timeless way of building&rdquo; calls &ldquo;quality without a name&rdquo;. I suppose I just didn&rsquo;t find it fun to type. So after re writing a couple of internal libraries in erlang to see what they looked like (they were much shorter and quite easy to read) I stopped using it, and started playing around with other languages like haskell and clojure.</p>

<p>Clojure was my first lisp dialect and I enjoy it alot, the syntax, the whole homoiconicity thing, macro&rsquo;s aren&rsquo;t something you should use all the time &ndash; but it&rsquo;s comforting to know they&rsquo;re there to fall back on if you need them.</p>

<p>Parallel to this functional language experimentation was another path &ndash; languages I used at work, which has seen me recently move from writing mostly in Python to Go. Go&rsquo;s channels and go routines are great, but when I started writing go code seriously (about 8 months ago) there was something that immediately stuck me.</p>

<p>```go
thing, err := someFunction()
if err != nil {</p>

<pre><code>//handle the error
</code></pre>

<p>}
```
Now, I&rsquo;m not going to start complaining about go&rsquo;s error handling, because I like it. But sometimes I would like to be able to make use of pattern matching and do something like this:</p>

<p><code>go
{thing, nil} = someFunction()
</code></p>

<p>And have my goroutine just dies if it fails. I know that&rsquo;s not go&rsquo;s philosophy with errors, and that&rsquo;s fine. I&rsquo;m just saying.</p>

<h2>Work and Fun Collide</h2>

<p>I&rsquo;ve spent the past 6 months saying to people that I would like a lisp dialect to be built onto go. What I really meant was I wanted a language that would let me do go style concurrency and play around with a repl, macros and all that functional programming <em>fun</em> stuff.</p>

<p>It looks to me that elixir provides exactly that.</p>

<p>Just look at these two programs. Both call a 10 second sleeping function on a seperate &lsquo;thread&rsquo; and wait for the response. The first in go, the second in elixir.
```go
package main</p>

<p>import (</p>

<pre><code>"fmt"
"time"
</code></pre>

<p>)</p>

<p>func longRun(response chan string) {</p>

<pre><code>time.Sleep(10e9)
response &lt;- "done"
</code></pre>

<p>}</p>

<p>func main() {</p>

<pre><code>response := make(chan string)
go longRun(response)
value := &lt;-response
fmt.Println(value)
</code></pre>

<p>}
<code>
</code>elixir
defmodule Main do</p>

<p>  def longRun(pid) do</p>

<pre><code>:timer.sleep(10000)
pid &lt;- {:result, :done}
</code></pre>

<p>  end</p>

<p>  def main() do</p>

<pre><code>spawn(__MODULE__, :longRun, [self])
receive do
  {:result, value} -&gt;
    IO.puts value
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>Main.main()
```</p>

<p>They&rsquo;re not too different, elixir has spawn where go has &lsquo;go&rsquo; and elxir has receive where go has select. There&rsquo;s no denying that they&rsquo;re completely different languages, in some rather crude tests I&rsquo;ve done go does seem to be largely faster, but elixir let&rsquo;s me do meta-programming whilst forgetting about types.</p>

<p>I expect to be blogging alot more about elixir in the future</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unique contraint in mongo]]></title>
    <link href="http://mattyw.github.io/blog/2013/06/12/unique-contraint-in-mongo/"/>
    <updated>2013-06-12T12:11:00+01:00</updated>
    <id>http://mattyw.github.io/blog/2013/06/12/unique-contraint-in-mongo</id>
    <content type="html"><![CDATA[<p>My first post on my new blog, so let&rsquo;s keep it simple.</p>

<p>In sql databases you can specify unique constrains on certain columns, like this example from postgres:</p>

<p>``` sql
create unique index idx_UniqRef on FooBar (</p>

<pre><code>   UniqRef ASC);
</code></pre>

<p>```
The question is: <strong>Is it possible to do this in a schema-less database like mongo?</strong>
Lets' start writing some code that we want to fail. For this I&rsquo;m going to use go and <a href="http://labix.org/mgo">Gustavo&rsquo;s mgo library</a></p>

<p><code>go
+package main
+
+import (
+  "labix.org/v2/mgo"
+  "log"
+)
+
+type FooBar struct {
+  Name   string
+  Age    int
+  UniqId int
+}
+
+func main() {
+  session, err := mgo.Dial("127.0.0.1")
+  if err != nil {
+    log.Fatal(err)
+  }
+
+  coll := session.DB("test").C("uniq_test")
+  coll.DropCollection()
+
+  a := FooBar{"Foo", 1, 1}
+  b := FooBar{"Bar", 2, 1}
+
+  err = coll.Insert(a)
+  if err != nil {
+    log.Fatal(err)
+  }
+  err = coll.Insert(b)
+  if err == nil {
+    log.Fatal("We wrote something but wanted to fail!")
+  }
+
+}
</code>
Nothing too fancy here:</p>

<ul>
<li>Create a connection to our collection

<ul>
<li>If the collection exists drop it (useful for iterating quickly on this test)</li>
</ul>
</li>
<li>Create two structures with a UniqId field duplicated</li>
<li>Insert both, if the second insert doesn&rsquo;t fail log an error</li>
</ul>


<p>If we run it as is, we see our failure
<code>bash
2013/06/12 13:14:51 We wrote something but wanted to fail!
exit status 1
</code></p>

<p>Now we&rsquo;re in a position to start looking into a solution, and it turns out we don&rsquo;t
have to look far. Just like postgres mongo has indexes, we can create one using ensureIndex.
Here&rsquo;s how it looks in the mgo library:</p>

<p>``` go</p>

<pre><code>//Let's try an index
index := mgo.Index{
    Key: []string{"uniqid"},
    Unique: true,
}
err = coll.EnsureIndex(index)
if err != nil {
    log.Fatal(err)
}
</code></pre>

<p>```</p>

<p>This creates an index on our uniqid field and forces it to be unique. If we call this code
before we try inserting here&rsquo;s what we get</p>

<p><code>bash
Failed to write! E11000 duplicate key error index: test.uniq_test.$uniqid_1  dup key: { : 1 }
</code></p>

<p>There we go, it also supports compound indexes which lets you specify multiple fields which must
be unique, but I&rsquo;m not going to cover that here. The <a href="http://docs.mongodb.org/manual/core/indexes/">mongo documention</a>
is a great source for more information</p>
]]></content>
  </entry>
  
</feed>
